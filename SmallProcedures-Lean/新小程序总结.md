#  新版小程序总结
## 全局配置文件app.json和底部导航配置
{
  "pages": [ 所有的页面都应该在这里书写
    "pages/index/index",
    "pages/logs/logs"
  ],
  "window": {
    "backgroundTextStyle": "light",下来刷新的时候,背景里面的,里面的文字的背景色
    "navigationBarBackgroundColor": "#000",顶部导航栏的背景色
    "navigationBarTitleText": "我的微信",页面的标题
    "navigationBarTextStyle": "white",页面标题的文字颜色
    "enablePullDownRefresh": true,开启下拉刷新
    "backgroundColor": "#ddd" 下拉刷新的时候,背景的颜色
  },
  "sitemapLocation": "sitemap.json" 是否允许小程序被搜索到,可以在sitemap.json里面配置到那些页面会被搜索到或者不会被搜索到
}
## 每一个页面里面的json
页面的json只配置window里面的内容,优先级高于全局配置,配置的时候默认就是window不需要家window的键
    {
      "navigationBarTitleText": "查看启动日志",
      "usingComponents": {}
    }
## 底部导航栏
    将跳转的连接放在tobBar里面,也上原有的连接将会失效
     "tabBar": {
        "list": [{
          "pagePath": ""pages/index/index",
          "text": "首页",
          "iconPath": "iconPath",按钮默认图标
          "selectedIconPath": "selectedIconPath" 按钮选中后的图标
        },
        {
                   "pagePath": "pages/logs/logs",
                   "text": "日志",
                   "iconPath": "iconPath",
                   "selectedIconPath": "selectedIconPath"
                 }
        ]
      }
## 页面分析
    wxml->html 不能直接使用html的标签
    wxss->css  兼容所有的css的样式
    js-> 微信小程序js里面是不能使用dom对象的,不存在windows对象,只是使用了js的核心语法

    <text> font+span 行内元素
    view   div  块级元素

    信息提示框
    wx.showToast({
        title:'这是提示框'
    })
## 页面声明周期函数
    onLanuch: 在app.js里面小程序在打开那一刻,首先触发的函数
    onLoad > onReady > onShow=onShow > onUnload页面卸载的时候
    onShareAppMessage 在分享之前就已经触发了
## swiper组件使用
     curent:默认显示的第几场图片(不仅仅是是图片,还可以是是页面)
     bindchange: 滚动改变的时候触发的事件
     autoplay:页面加载后自动滚动
     interval:页面加载多久后自动滚动
     duration:两张图片滚动的时间间隔
     circular:无缝滚动
     indicator-dots:是否出现焦点
     vertical:true 竖向滚动,(竖向滚动必须要给swiper一个高度)
     以上是一部分
     <swiper current="1" bindchange="changeCurrent" autoplay interval="2000" duration="700" circular indicator-dots>
        <swiper-item>
          <navigator url="/pages/about/about">
            <image src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571130748624&di=cf3b9e291be38dc5af4d9624bfd85951&imgtype=0&src=http%3A%2F%2Fpic2.16pic.com%2F00%2F01%2F24%2F16pic_124090_b.jpg" ></image>
          </navigator>
        </swiper-item>
        <swiper-item>
          <navigator>
            <image src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571130748624&di=fc52dc00493f3882484a2cb1dceff445&imgtype=0&src=http%3A%2F%2Fpic.baike.soso.com%2Fp%2F20100505%2F20100505154727-2016523917.jpg"></image>
          </navigator>
        </swiper-item>
     </swiper>
## scroll-view
    scroll-x:横向滚动
    里面的每一项需要自己设置横向排列
    <scroll-view scroll-x>
      <view class="view-container">
          <view class="view-con">
            <image src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571130748624&di=fc52dc00493f3882484a2cb1dceff445&imgtype=0&src=http%3A%2F%2Fpic.baike.soso.com%2Fp%2F20100505%2F20100505154727-2016523917.jpg" class="img"></image>
            <view>
              <view class="news-title">学习标题01</view>
              <text class="fnt-content">微信课程,滑块学习</text>
            </view>
          </view>
            <view class="view-con">
              <image src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571130748624&di=fc52dc00493f3882484a2cb1dceff445&imgtype=0&src=http%3A%2F%2Fpic.baike.soso.com%2Fp%2F20100505%2F20100505154727-2016523917.jpg" class="img"></image>
              <view>
                <view class="news-title">学习标题02</view>
                <text class="fnt-content">微信课程,滑块学习</text>
              </view>
            </view>
      </view>
    </scroll-view>
##  audio 组件 api的形式
    const myAudio=wx.createInnerAudioContext();创建音频对象
    myAudio.play();//播放音频
    myAudio.pause();//暂停音频
    myAudio.seek(12);跳转到指定的秒数
##  video 组件
     <video id="muvideo" enable-danmu danmu-list="{{danmulist}}" controls danmu-btn class="video"  src="{{src}}"></video>
     //enable-danmu :是否开启弹幕,danmu-list:弹幕列表 controls:开启按钮 danmu-btn :开启关闭弹幕按钮
     getVideo(){
         let that=this;
         wx.chooseVideo({ //微信api选择视频
           sourceTpye:['camera','album'],//视频来源,照相机拍摄或者相册
           maxDuration:60,//视频最长时间
           camera:['front','back'],//开启,前后摄像头
           success(res){
             that.setData({
               src: res.tempFilePath
             })
           }
         })
       }
     创建视频对象:this.videoContext = wx.createVideoContext('muvideo', this) muvideo视频组装件id
     发送弹幕:
     this.videoContext.sendDanmu({//视频独享,发送弹幕方法
           text:this.inputVlue,
           color:randomColor() //随机字体颜色
      })
    function randomCOlor(){
      let rgb=[];
      for(let i=0;i<3;i++){
        let color=Math.floor(Math.random()*256).toString(16);
        color=color.length==1 ? '0'+color:color;
        rgb.push(color);
      }
      return '#'+rgb.join('');
    }
## 移动
    movable-arae:移动区域
    movable-view:移动元素
            direction:'all' //全方位移动
            direction:'vertical' //水平方向移动
            direction: 'horizontal' //竖直方向移动
            direction: 'none' //不移动,配合x,y可以固定view的位置
            x:x轴的起始位置
            y:y轴的起始位置
    <view>全方位移动</view>
    <movable-area class="area">
        <movable-view direction='all' class="view"></movable-view>
    </movable-area>
    <view>在一个area里面多个view移动</view>

    <movable-area class="area">
        <movable-view direction='horizontal' class="view red"></movable-view>
        <movable-view direction='vertical' class="view yellow"></movable-view>
    </movable-area>
    <view>固定位置</view>
    <view>设置x,y坐标 ditection 为null</view>
    <movable-area class="area">
        <movable-view direction='none' x='50rpx' y="50rpx" class="view"></movable-view>
    </movable-area>
## 微信上面你的弹性布局
    display:flex;
    flex-direction:row/column;//主轴方向
    justify-content:flex-start/flex-end/center/space-round
    flex-wrap:wrap/nowrap //是否换行
    align-items:flex-star/flex-end;center;
## wx:for
    wx:for里面的wx:key可以对循环渲染起到性能优化作用,有wx:key的时候,会根据wx:key进行渲染,没有的话,则需要循环整个数据
    wx:if,hidden:
        wx:if 条件不成立的时候,则不会渲染数据
        hidden hidden只是元素不显示,但是元素还会被渲染
    template,block
        template 作为模板使用,一般不希望现实tempate的标签,模板的高级用法,可以在外面单独建立模板文件引入,模块化开发
        block 作为对代码片段的控制
    template 用法的例子
              template 作为引入模板,再引入其它模板的话,容易混乱
            <!-- 一般用法 -->
            <template name="studentInfo">
              <view>
                姓名:{{student.name}}
              </view>
              <view>
                年龄:{{student.age}}
              </view>
            </template>
            <template is="studentInfo" data="{{student}}" />
            <!-- 解构用法 -->
            <template name="studentInfo1">
              <view>
                姓名:{{name}}
              </view>
              <view>
                年龄:{{age}}
              </view>
            </template>
            <template is="studentInfo1" data="{{...student}}" />
            <!-- 一般用法 -->
            <template name="studentInfo2">
              <block wx:for="{{stuArr}}" wx:key="{{item}}">
                <view>
                  姓名:{{item.name}}02
                </view>
                <view>
                  年龄:{{item.age}}02
                </view>
              </block>
            </template>
            <template is="studentInfo2" data="{{stuArr}}" />

            <!-- 循环模板用法 -->
            <template name="studentInfo3">
                <view>
                  姓名:{{item.name}}
                </view>
                <view>
                  年龄:{{item.age}}
                </view>
            </template>
            <view  wx:for="{{stuArr}}" wx:key="{{item}}">
              <template is="studentInfo3" data="{{item}}" />
            </view>
            <!-- 解构用法 -->
            <template name="studentInfo4">
                <view>
                  姓名:{{name}}
                </view>
                <view>
                  年龄:{{age}}
                </view>
            </template>
            <view  wx:for="{{stuArr}}" wx:key="{{item}}">
              <template is="studentInfo4" data="{{...item}}" />
            </view>


            <!-- 引用模板 -->
            <import src="/template/studentInfo.wxml"/>

            <!-- 使用模板 -->
            <view  wx:for="{{stuArr}}" wx:key="{{item}}">
              <template is="studentInfo5" data="{{...item}}" />
            </view>
            <!--引入模板 -->
            <!-- 包含模板里面不可有template模板 -->
            <include src="/template/include.wxml" />

            引入的两个模板
            include.wxml
                <view>
                  我这边是包含模板
                </view>
            studentInfo.wxml
             <template name="studentInfo5">
                 <view>
                   姓名:{{name}} 我是外面引入的模板
                 </view>
                 <view>
                   年龄:{{age}} 我是外面引入额模板
                 </view>
             </template>
#richtext 和progress
    richtext:
        nodes:可以是字符串,自古穿里面可以有标签,也可以是数组,数组的时候,要按照一定的格式
        <view>
          <view>富文本编辑器 nodes=strings</view>
          <rich-text nodes="{{strings}}"></rich-text>
        </view>
        strings:'<h1>这是富文本编辑器</h1>',
        <view>
          <view>富文本编辑器 nodes=array</view>
          <rich-text nodes="{{nodesArr}}"></rich-text>
        </view>
        nodesArr:[
                      {
                        name: 'h4',
                        attrs:{
                          style:'color:red;'
                        },
                        children:[
                          {
                            type:'text',
                            text:'子节点标题'
                          }
                        ]
                      }
        ]

        process:
        percent:开始的时候的比例
        stroke-width:进度条的高度
        color:进度条的颜色
        active:是否开启动画
        show-info:是否在进度条右侧显示百分比
        <progress percent="100" show-info stroke-width="14" color="pink" active="true" >
         <view class="title-line">procress</view> //此处的文字会出现在百分比的后面
        </progress>
##  from 小程序的所有的提交上都是异步的
        bindsubmit:提交的时候触发,formSubmit后台定义的方法
        bindreset:数据重置的时候触发,formReset后台的定义方法
        from-type:属性必须要写,后面的form-type的属性,是固定的submit,reset方法
        <form bindsubmit="formSubmit" bindreset="formReset">
        <input name="userName"></input> 只有有name属性,后台才能收到的值
            <button form-type="submit">Submit</button>
            <button form-type="reset">Reset</button>
        </form>
## input
        <input confirm-type="search"></input>
        <input placeholder="name" maxlength="" focus placeholder-style="color:red"  bindinput="inputBind" bindfocus="getFocus" bindblur="blur" bindconfirm="confirm" placeholder-class="bg"></input>
        confirm-type:search,//键盘右下角的文字, send,next,go,done
##  checkbox
      <view>checkbox</view>
      <checkbox-group bindchange='checkbind'> 一组checkbox里面的改变都会触发checkbind方法
        <checkbox value="1011">1011</checkbox>
        <checkbox value="1012" checked>1012</checkbox>
      </checkbox-group>
       <checkbox-group  bindchange="checkChange">
        <label wx:for="{{items}}" wx:key="{{index}}">
          <checkbox value="{{item.name}}" checked="{{item.checked}}">{{item.name}}</checkbox>
        </label>
      </checkbox-group>
      <view>editor</view>
      showImgToolbar:显示图片上传按钮
      showImgSize:显示图片大小
      showImgResize:开启图片可缩放
      bindstatuschange:监听edirtor的变化
      <editor placeholder="this is a editor" id="editor" showImgToolbar showImgSize showImgResize  bindstatuschange="statusChange"></editor>
      <view>radio</view>
      <radio-group bindchange='radioChange'> 一组radiobox里面的改变都会触发radiobox方法
        <view wx:for="{{radioArr}}"  wx:key="{{index}}">
            <label for="{{item.name}}">点赞</label>
            <radio id="{{item.name}}" value="{{item.name}}" name="{{item.name}}" checked="{{item.checked}}">{{item.value}}</radio>
        </view>
      </radio-group>
## picker
        //所有数据变化都在事件的e里面
        //mode 类型 selector:单行选择,multiSelector:多列选择,time:时间选择,date:日期选择,city:城市选择
        //value:默认值
        //range:数据来源 city的数据源由微信小程序自动提供
        //数据的变化都在绑定事件的e参数里面
         data: {
            city:['','',''],
            date:'',
            time:'',
            multiIndex:[0,0,0],
            index:0,
            multiArray:[
              ['中国','北京'],
              ['美国','纽约'],
              ['日本','大阪'],
              ['英国','伦敦','开普勒']
            ],
            country: ['中国','美国','日本','英国'],
            radioArr:[
              {name:'top',checked:false,value:'top'},
              { name: 'tom', checked: false, value: 'tom' },
              { name: 'lily', checked: true, value: 'lily' },
              { name: 'judy', checked: false, value: 'judy' }
            ],
            items:[
              {
                name:'top',value:'CHA'
              },
              {
                name: 'alis', value: 'CHA'
              },
              {
                name: 'tom', value: 'CHA',checked:true
              },
              {
                name: 'lyly', value: 'CHA'
              }

            ]
          }
      <view>picker</view>
      <picker bindchange="pickChange" mode="selector" value="{{index}}" range="{{country}}">
        <view>当前选择:{{country[index]}}</view>
      </picker>
      <view>多列选择器:</view>
      <picker mode="multiSelector" bindchange="multiChange" bindcolumnchange="coloumnChange" value='{{multiIndex}}' range="{{multiArray}}" >
        <view>当前选择:{{multiArray[0][multiIndex[0]]}}</view>
      </picker>
      <view>时间</view>
      <picker mode='time' start='09:00' end="21:00" bindchange="timeChange" >
        <view>当前时间:{{time}}</view>
      </picker>
      <picker mode='date' start='2015-09-10' end='2100-09-10' bindchange="dateChange">
          <view>当前日期:{{date}}</view>
      </picker>
      <view>省市选择</view>
      <picker mode='region' bindchange="cityChange">
        <view>当前选择:{{city}}</view>
      </picker>
     <view>slide滑动选择器</view>
     <view>设置step</view>
     step:每一步滑动距离的
     show-value:显示数值
     min:最小值
     max:最大值
     <slider step="5" bindchange="slideChane" show-value min="50" max="200"></slider>
      <view>switch</view>
     <switch bindchange="switchChange"></switch>
     <switch checked bindchange="switchChange"></switch>
     <view>textarea</view>
     <view>
        auto-height:根据输入内容自动的高度
        auto-focus:获取焦点的时候,自动弹出键盘
       <textarea value="this is textarea" bindblur="areaChange" auto-height auto-focus="true"></textarea>
     </view>
##  导航
        组件跳转
        <navigator target="self" url="/pages/about/about" open-type="redirect">跳转操作redirect</navigator>//跳转以后,无法返回
        <navigator target="self" url="/pages/about/about" open-type="navigate">跳转操作navigate</navigator>//跳转以后,其它打开的页面还是打开的
        <navigator target="self" url="/pages/about/about" open-type="switchTab">跳转操作switchTab</navigator>//需要后台的支持,url的页面,必须在app.json的tapbar里面配置的页面,才能跳转
        <navigator target="self" url="/pages/about/about" open-type="reLauunch">跳转操作reLauunch</navigator>//跳转以后,关闭其它已经打开所有页面
        <navigator target="self" url="/pages/about/about" open-type="navigateBack">跳转操作navigateBack</navigator>//打开页面以后,可以通过这个按钮回退
        <navigator target="miniProgram"  open-type="exit">小程序调换</navigator>//跳转到新的小程序,关闭当前小程序,ios不支持
        微信接口跳转
         wx.switchTab({//只能跳转到tabar里面设置过的页面
              url: '/pages/usercenterDemo/usercenterDemo',
         })
         wx.redirectTo({//不能跳转到tabar里面设置过的页面
           url: '/pages/moveableDemo/moveableDemo',
         })
         wx.reLaunch({//不能跳转到tabar里面设置过的页面
           url: '/pages/moveableDemo/moveableDemo',
         })
         wx.navigateTo({ //不能跳转到tabar里面设置过的页面
           url: '/pages/moveableDemo/moveableDemo',
         })
         wx.navigateBack({//不能跳转到tabar里面设置过的页面
           url: '/pages/moveableDemo/moveableDemo'
         })
## camera
        device-position:'front/back'默认打开的是前置摄像头,还是后置摄像头
        flash:off/on;是否开启闪光灯
          <camera class="camera-cls" device-position="front" flash="off"  >
            <cover-view class="main-tips">photo</cover-view>//覆盖在照相机上面的文字
            <cover-image class="cover-img" src="/image/rx.png"></cover-image>//覆盖在照相机上面的图片
            <cover-image class="hd" bindtap="takePhoto" src="/image/hd.png"></cover-image>//按下拍照后触发的事件
         </camera>
         takePhoto(){
             const ctx=wx.createCameraContext(this);//创建camera对象
             ctx.takePhoto({
               quality:'high',//照片质量
               success:(res)=>{//拍摄成功后的回调函数
                 //设定到缓存
                 wx.setStorage({//放入缓存
                   key: 'photoPeople',
                   data: res.tempImagePath
                 })
                 wx.redirectTo({//页面跳转
                   url: '/pages/caneraDemo/photo'
                 })
               }
             })
           }
#   map组件
        latitude:地图中心点的纬度
        longitude:地图中心的的经度
        markers:标记点
        cover:覆盖点
        show-location:显示带有方向的当前定位点
        <map id="mymap" style="width:100%;height:600rpx;"
                latitude="{{latitude}}"
                longitude="{{longitude}}"
                markers="{{markers}}"
                cover="{{covers}}"
                show-location
              ></map>
        data数据:
         data: {
            latitude:23.09994,
            longitude:113.234520,
            markers:[
              {
                id:1,
                latitude: 23.09994,
                longitude: 113.234520,
                name:'T创业园'
              }
            ],
            covers:[
              {
                latitude: 23.09994,
                longitude: 113.334520,
                iconPath:'/image/location.png'
              },
              {
                latitude: 23.09994,
                longitude: 113.304520,
                iconPath: '/image/location.png'
              }
            ]
         }
         部分API:
         创建地图对象:this.mapCtx=wx.createMapContext('mymap', this)
         获取中心的位置:
         this.mapCtx.getCenterLocation({
               success(res){
                       that.setData({
                         latitude:res.latitude,
                         longitude:res.longitude
                       })
                     }
         })
         移动位置 默认的是移动到你所在的位置
         this.mapCtx.moveToLocation();
         移动标注
          this.mapCtx.translateMarker({
             markerId:1,
             autoRotate:true,
             duration:2000,
             destination:{
               latitude:23.10339,
               longitude:113.3345211
             },
             animationEnd(){
               console.log('end');
             }
          })
         缩放地图
          this.mapCtx.includePoints({
           padding:[10],
           points:[
             {
               latitude: 23.10229,
               longitude: 113.3345211
             },
             {
               latitude: 23.00229,
               longitude: 113.3345211
             }
           ]
         })
#  canvas
           <!-- 同一个页面中canvas-id不可重复,如果过重复了将会隐藏不工作 -->
           disable-scroll:禁止下拉的时候,画布滚动
         <canvas
         canvas-id="myCanvas"
         class="myCanvas"
         disable-scroll="false"
         bindtouchstart="touchStart"
         bindtouchmove="touchMove"
         bindtouchend="touchEnd"
         ></canvas>
         ```
         Page({
           data: {
             pen: 3, //画笔粗细默认值
             color: '#000' //画笔颜色默认值
           },
           startX: 0, //保存X坐标轴变量
           startY: 0, //保存X坐标轴变量
           isClear: false, //是否启用橡皮擦标记
           //手指触摸动作开始
           touchStart: function (e) {
             //得到触摸点的坐标
             this.startX = e.changedTouches[0].x
             this.startY = e.changedTouches[0].y
             this.context = wx.createContext()

             if (this.isClear) { //判断是否启用的橡皮擦功能  ture表示清除  false表示画画
               this.context.setStrokeStyle('#F8F8F8') //设置线条样式 此处设置为画布的背景颜色  橡皮擦原理就是：利用擦过的地方被填充为画布的背景颜色一致 从而达到橡皮擦的效果
               this.context.setLineCap('round') //设置线条端点的样式
               this.context.setLineJoin('round') //设置两线相交处的样式
               this.context.setLineWidth(20) //设置线条宽度
               this.context.save();  //保存当前坐标轴的缩放、旋转、平移信息
               this.context.beginPath() //开始一个路径
               this.context.arc(this.startX, this.startY, 5, 0, 2 * Math.PI, true);  //添加一个弧形路径到当前路径，顺时针绘制  这里总共画了360度  也就是一个圆形
               this.context.fill();  //对当前路径进行填充
               this.context.restore();  //恢复之前保存过的坐标轴的缩放、旋转、平移信息
             } else {
               this.context.setStrokeStyle(this.data.color)
               this.context.setLineWidth(this.data.pen)
               this.context.setLineCap('round') // 让线条圆润
               this.context.beginPath()

             }
           },
           //手指触摸后移动
           touchMove: function (e) {
             var startX1 = e.changedTouches[0].x
             var startY1 = e.changedTouches[0].y

             if (this.isClear) { //判断是否启用的橡皮擦功能  ture表示清除  false表示画画

               this.context.save();  //保存当前坐标轴的缩放、旋转、平移信息
               this.context.moveTo(this.startX, this.startY);  //把路径移动到画布中的指定点，但不创建线条
               this.context.lineTo(startX1, startY1);  //添加一个新点，然后在画布中创建从该点到最后指定点的线条
               this.context.stroke();  //对当前路径进行描边
               this.context.restore()  //恢复之前保存过的坐标轴的缩放、旋转、平移信息

               this.startX = startX1;
               this.startY = startY1;

             } else {
               this.context.moveTo(this.startX, this.startY)
               this.context.lineTo(startX1, startY1)
               this.context.stroke()

               this.startX = startX1;
               this.startY = startY1;

             }
             //只是一个记录方法调用的容器，用于生成记录绘制行为的actions数组。context跟<canvas/>不存在对应关系，一个context生成画布的绘制动作数组可以应用于多个<canvas/>
             wx.drawCanvas({
               canvasId: 'myCanvas',
               reserve: true,
               actions: this.context.getActions() // 获取绘图动作数组
             })
           },
           //手指触摸动作结束
           touchEnd: function () {

           },
           //启动橡皮擦方法
           clearCanvas: function () {
             if (this.isClear) {
               this.isClear = false;
             } else {
               this.isClear = true;
             }
           },
           penSelect: function (e) { //更改画笔大小的方法
             console.log(e.currentTarget);
             this.setData({ pen: parseInt(e.currentTarget.dataset.param) });
             this.isClear = false;
           },
           colorSelect: function (e) { //更改画笔颜色的方法
             console.log(e);
             console.log(e.currentTarget);
             this.setData({ color: e.currentTarget.dataset.param });
             this.isClear = false;
           }
         })
         ```
##  open-data
    <view>
      <open-data type="userNickName"  lang="zh_CN" ></open-data>//昵称
    </view>
    <view>
      <open-data type="userAvatarUrl"  lang="zh_CN"></open-data>//头像
    </view>
    <view>
      <open-data type="userGender"  lang="zh_CN" ></open-data>//性别
    </view>
    <view>
      <open-data type="userCity"  lang="zh_CN" ></open-data>//城市
    </view>
    <view>
      <open-data type="userProvince"  lang="zh_CN" ></open-data>//省
    </view>
    <view>
      <open-data type="userCountry"  lang="zh_CN"></open-data>//国家
    </view>
    <view>
      <open-data type="userLanguage" lang="zh_CN" ></open-data>//语言
    </view>
##  web-view
    <web-view></web-view> //web-view类似web端的iframe,可以把页面引进小程序,而不同的是,小程序提供了页面和小程序的通信方法
## API
        1:wx.downLoadFile
        <button bindtap="downLoadFile">下载</button>
        <progress show-info percent="{{percent}}"></progress>
        <image src="{{src}}"></image>
       let that=this;
       const downloadTask= wx.downloadFile({//每一个微信的api都会返回一个监听对象,来监视api的运行情况
            url:this.filePath,
            success:(res)=>{
              console.log(res);
              this.setData({
                src:res.tempFilePath
              })
            },
            error:()=>{

            },
            complete:()=>{

            }
          })
        // downloadTask.abort();//终止下载任务
        downloadTask.onProgressUpdate(res=>{//监听下载进度
           console.log('下载进度',res.progress);//下载进度
           console.log('已经下载',res.totalBytesWritten);//已经下载总量
           console.log('下载总长度',res.totalBytesExpectedToWrite);//下载总量
           that.setData({
             percent: res.totalBytesWritten / res.totalBytesExpectedToWrite*100//设置了进度条
           })
           that.setData({
             percent: res.progress
          })
        })
        2:wx.chooseImage,wx.uploadFile
        wx.chooseImage({
          success: function(res) {
            console.log(res);
            const uploadTask = wx.uploadFile({
              url: 'https://www.baidu.com',
              filePath: res.tempFilePaths[0],
              name: 'pic1',
              success:(res)=>{
                console.log(res);
              },
              error:(err)=>{
                console.log('错了',err);
              }
            })
          },
        })
#录音和播放
       1:停止维护版本
       //开始录音
         recordVoice(){
           let  that=this;
           wx.startRecord({ //开始录音
             success(res){//录音完成
               console.log('success',res);
               that.tempVoice=res.tempFilePath
             },
             fail(res){//录音失败触发
                 console.log('falil',res);
             }
           })
           setTimeout(()=>{
               wx.stopRecord();//关闭录音
           },5000)
         },
         /**
          * 播放音频
          */
         playVoice(){
           let that=this;
           wx.playVoice({//播放录音
             filePath: that.tempVoice
           })
         }
       2:推荐版本
           const recorderManager=wx.getRecorderManager();
           const innerAudioContext=wx.createInnerAudioContext();
         /***
          * 开始录音
          */
         start(){
           const options={
             duration:10000,//录音时长
             sampleRate:16000,//采样率
             numberOfChannels:1,//录音通道数
             encodeBitRate:96000,//编码码率
             format:'mp3',//音频格式,有效aac/mp3
             frameSize:50//指定帧大小,单位kb
           }
           recorderManager.start(options);//来时录音
           recorderManager.onStart(()=>{//监听开始录音
               console.log('start');
           })
           recorderManager.onError((err)=>{//录音出错
             console.log(err);
           })
         },
         /**
          * 停止录音
          */
         stop(){
           let that=this;
           recorderManager.stop();//停止录音
           recorderManager.onStop((res)=>{//监听停止录音
             that.tempFilePath=res.tempFilePath;
             console.log('停止录音',res.tempFilePath);
           })
         },
         /**
          * 播放录音
          */
         play(){
           innerAudioContext.autoplay=true;//设置录音伯刚
           innerAudioContext.src = that.tempFilePath;
           innerAudioContext.onPlay(()=>{//播放录音
             console.log('播放');
           })
           innerAudioContext.onError((err)=>{//播放录音出错 触发事件
             console.log('err');
           })
         }
##   websocket
       senMsg(){
        let that = this;
        wx.sendSocketMessage({
          data: that.message
        })
        //监听数据是否成功
        wx.onSocketMessage((data) => {
          console.log('接收到服务器的数据', data);
          that.setData({
            respnoseMessage: data.data.replace("[<a href='http://coolaf.com/tool/chattest'>http://coolaf.com</a>]",'')
          })
        })
        wx.onSocketError((data => {
          console.log(data);
          that.setData({
            respnoseMessage:data.data
          })
        }))
      },
      /**
       * 获取发送内容
       */
      recodeMessage(e){
        this.message=e.detail.value;
      },
      /**
     * 生命周期函数--监听页面显示
     */
    onShow: function () {
      //建立连接
      wx.connectSocket({
        url: 'ws://123.207.167.163:9010/ajaxchattest' //临时在线测试地址
      })
      //判断连接是否成功
      wx.onSocketOpen(() => {
        console.log('打开连接成功');
      })
    },

    /**
     * 生命周期函数--监听页面隐藏
     */
    onHide: function () {
      //关闭连接
      wx.closeSocket({});
      //关闭连接失败
      wx.onSocketClose(() => {
        console.log('关闭了');
      });
    },
##  背景音乐
    1:第一种   BackgroundAudio
     /**
       * 播放
       */
      play(){
        console.log(url);
        wx.playBackgroundAudio({
          dataUrl: url,
          title:'此时此刻',
          coverImgUrl:'http://y.gtimg.cn/music/photo_new/T002R300x300M000003rsKF44GyaSk.jpg?max_age=2592000'
        })
        wx.onBackgroundAudioPlay(()=>{
          console.log('开始播放了');
        })
      },
      /**
       * 暂停
       */
      pause(){
        wx.pauseBackgroundAudio();
        wx,wx.onBackgroundAudioPause(()=>{
          console.log('暂停');
        })
      },
      /**
       * 停止
       */
      stop(){
        wx.stopBackgroundAudio();
        wx.onBackgroundAudioStop(()=>{
          console.log('stop');
        })
      },
      /**
       * 跳转
      */
      seek(){
        wx.seekBackgroundAudio({
          position: 20,
        })
      },

      2:第二种 backgroundAudioManager
      const backgroundAudioManager=wx.getBackgroundAudioManager();
      /**
         * 播放
         */
        play(){
          backgroundAudioManager.title='此时此刻';
          backgroundAudioManager.epname='此时此刻';
          backgroundAudioManager.singer='许巍';
          backgroundAudioManager.coverImgUrl ='http://y.gtimg.cn/music/photo_new/T002R300x300M000003rsKF44GyaSk.jpg?max_age=2592000';
          backgroundAudioManager.src ='http://ws.stream.qqmusic.qq.com/M500001VfvsJ21xFqb.mp3?guid=ffffffff82def4af4b12b3cd9337d5e7&uin=346897220&vkey=6292F51E1E384E06DCBDC9AB7C49FD713D632D313AC4858BACB8DDD29067D3C601481D36E62053BF8DFEAF74C0A5CCFADD6471160CAF3E6A&fromtag=46';
        },
        /***
         * 暂停
         */
        pause(){
          backgroundAudioManager.pause();
          backgroundAudioManager.onPlay(()=>{
            console.log('暂停');
          })
        },
        /**
         * 停止
         */
        stop(){
         backgroundAudioManager.stop();
         backgroundAudioManager.onStop(()=>{
           console.log('stop');
         })
        },
        /*
        *跳转
        */
        seek(){
          backgroundAudioManager.seek(20);
        }
##  图片
       1:选择图片
       chooseimage(){
           let  that=this;
           wx.chooseImage({//选择图片
             success: function(res) {
               console.log(res); //获取图片结果
                 that.setData({
                   upateImage: res.tempFilePaths
                   tempFilePaths: res.tempFilePaths
                 })
             }
           })
       }
       2:获取图片相关信息
        getImageInfo(){
           let that=this;
           wx.getImageInfo({
             src: that.data.tempFilePaths[0] //图片路径
             success(res){
               console.log(res);
             }
           })
         }
       3:预览图片
        previewImage(){
           let that=this;
           wx.previewImage({
             urls: [that.data.tempFilePaths[0]] //预览图片的地址,可以是多个
           })
        }
       4:下载保存图片
        downLoadService(){ //下载保存都在一起写
           let that=this;
            wx.downloadFile({//下载文件
              url:that.data.serviceImage,//下载文件路径
              success(res){
               wx.saveImageToPhotosAlbum({//保存到相册
                  filePath: res.tempFilePath,
                  success(){
                    console.log('保存成功了');
                  },
                  fail(err){
                    console.log(err);
                  }
                })
              }
            })
        }
##  loading 层
    1:内部组件loading层
         <loading hidden="{{true}}">加载中</loading>
    2:api的形式loading层
        1:wx.showToast
            wx.showToast({
             title: '加载中',
             icon:'loading',
             duration:2000, //2m后关闭
             mask:true
            })
         wx.hideToast();//关闭时间前,提前关闭层
        2:showLoading
            wx.showLoading({
              title: '加载中'
            })
            wx.hideLoading();//关闭
##  文件操作
     /**
       * 保存文件
       * 保存文件到本地,会移动临时文件
       */
      saveFile(){
        wx.chooseImage({
          success: function(res) {
            const tempfile=res.tempFilePaths[0];
            //保存
            wx.saveFile({
              tempFilePath: tempfile,
              success(res){
                const saveFilePath=res;
                console.log(saveFilePath)
                //图片存储的路径; C:\Users\Administrator\AppData\Local\微信开发者工具\User Data
                //搜索文件名
              }
            })
            //保存至相册
            wx.saveImageToPhotosAlbum({
              filePath: tempfile,
              success(res){
                  console.log(res);
              }
            })
            //保存至视频目录
            wx.saveVideoToPhotosAlbum({
              filePath: tempfile,
              success(res){
                console.log('保存到视频目录');
              }
            })
          },
        })
      },
      /***
       * 获取本地临存储文件
       */
      getFileInfo(){
        wx.chooseImage({
          success: function(res) {
            wx.getFileInfo({
              filePath: res.tempFilePaths[0],
              success(res){
                console.log(res);
                console.log(res.size);//文件大小
                console.log(res.digest);//计算算法 md5/sha1
              }
            })
          },
        })
      },
      /***
       *获取保存文件列表
       */
      getSaveFileList(){
        wx.getSavedFileList({
          success(res){
            console.log(res);
          }
        })
      },
      /**
       * 删除临时文件列表
       */
      removeSaveFile(){
        wx.getSavedFileList({
          success(res){
            //删除
            for(let i=0;i<res.fileList.length;i++){
                wx.removeSavedFile({
                  filePath: res.fileList[i].filePath,
                  success(e){
                    console.log('success',e);
                  },
                  fail(e){
                    console.log('fail',e);
                  },
                  complete(e){
                    console.log('complete',e);
                  }
                })
            }
          }
        })
      },
      /***
       * 打开文件
       */
      openDocument(){
        wx.downloadFile({
          url:'http://g.hiphotos.baidu.com/image/pic/item/c2cec3fdfc03924590b2a9b58d94a4c27d1e2500.jpg',
          success(res){
            console.log(res);
            wx.openDocument({
              filePath: res.tempFilePath,//打开文件路径
              fileType:'jpeg',
              success(res){
                console.log('文件已经打开',res);
              },
              fail(e){
                console.log(e);
              }
            })
          },
          fail(e){
            cosnole.log(e);
          }
        })
      }
## 缓存
     /**
       * 设置缓存
       * Sync:同步
       *wx.setStorageSync
       */
      setStorage(){
        wx.setStorage({
          key: 'name',//..不可重复,不可不写
          data: 'tom',
          success(e){
              console.log('已经存好了');
          }
        })
      },
      /**
       * 移出缓存
       * Sync:同步
       * wx.removeStorageSync
       */
      removeStorage(){
        wx.removeStorage({
          key: 'name',
          success: function(res) {
            console.log('移出成功');
          },
        })
      },
      /***
       * 获取缓存
       * Sync:同步
       * wx.getStorageInfoSync
       */
      getStorage(){
       wx.getStorageInfo({
         success: function(res) {
           console.log(res);
         },
       })
      },
      /**
       * 清除缓存数据
       * Sync:同步
       * wx.clearStorageSync
       */
      clearStorage(){
        wx.clearStorage();
      },
      案例:页面传值
## 页面之前的传值的几种方式
    1:缓存传值
        当前页面存储值
        wx.setStorage({
         key: 'id',
         data: '缓存:code101',
       })
       另一个页面取值
        wx.getStorage({
           key: 'id',
           success: function(res) {
             that.setData({
               cacheparam:res.data
             })
             wx.removeStorage({ //取出来值以后,清楚缓存
               key: 'id',
               success: function (res) {
                 console.log('删除成功');
               },
             })
           },
         })
     2:组件url传值
        当前页面
        <navigator url="/pages/cache/cache?param=urlcode001">navigtor带参数跳转</navigator>
        另一个页面:
         onLoad: function (options) {
              this.setData({
                urlparam: options.param //获取传递过来的参数
              })

          }
    3:api跳转传值
        当前页面的js文件
          wx.navigateTo({
          url: '/pages/cache/cache?apiParam=apicode001',
        })
        另一个页面
         this.setData({
            apiparam: options.apiParam //取出来传递的参数
          })
    4:全局变量传值
        两个页面都要引入全局的app
        const app=getApp();
        当前页面:
         app.globalData.globalApi ='globalApidode001'
        另一个页面:
         this.setData({
               globalApi:app.globalData.globalApi
         })
    5:剪贴板
      当前页面
      wx.setClipboardData({//赋值
         data: that.data.text,
         success(){
            wx.showToast({
              title: 'ccopycode001',
            })
         }
       })
       另一个页面
        wx.getClipboardData({//取值
         success(res){
          that.setData({
            copytext:res.data
          })
         }
       })
##  内存警告
    //监控内存的警告
    wx.onMemoryWarning(()=>{
      console.log('内存警告');
      //清空缓存
      wx.clearStorage();
      wx.showToast({
        title: '玩得太久了,手机内存不够用了',
      })
    })
#  剪贴板
    设置剪贴板
      wx.setClipboardData({
       data: that.data.text,
       success(){
          wx.showToast({
            title: '复制成功',
          })
       }
     })
     获取剪贴板
      wx.getClipboardData({
       success(res){
        that.setData({
          copytext:res.data
        })
       }
     })
# 微信扫码和生成二维码
    1:扫码:
    /***
       * 扫一扫
       */
      onScan() {
        let that=this;
        wx.scanCode({//直接扫描二维码或者从相册选取
          success: (res) => {
            console.log(res);
            let msg = '';
            if (res.scanType === 'WX_CODE' && res.result === '') {
              msg = '宝宝心里苦，但宝宝不说...'
            }
            that.setData({
              scanResult: {
                isShow: true,
                type: scanType[res.scanType],
                text: res.result,
                msg,
              },
            });

            // 存入Storage
            if (that.data.scanResult.text !== '') {
              wx.getStorage({//取缓存
                key: 'scanLogs',
                fali(err){
                  console.log('err',err);
                },
                success: (res) => {
                  let scanLogs = res.data || [];
                  console.log(that.data.scanResult);
                  that.data.scanResult.date = Date.now();
                  scanLogs.unshift(that.data.scanResult);
                  wx.setStorageSync('scanLogs', scanLogs);//设置缓存
                }
              })
            }
          }
        })
      }
     2:生成二维码
     let that = this
        wx.downloadFile({
          url:"http://qr.topscan.com/api.php?text="+this.data.codeText,//在线生成二维码地址
          success(res){
            //console.log(res)
            that.setData({
              imgTempFilePath: res.tempFilePath//生成的二维码地址
            })

          },
          fail(res){
            console.error('error',res)
          }
        })
      }
## 手机震动和截屏功能
    1:手机振动
     wx.vibrateLong({ //长时间震动
        success(){
          console.log('长时间震动');
        }
     })
     wx.vibrateShort({//短时间震动
           success(){
             console.lg('短时间震动');
           }
     })
     2:添加到微信好友
     wx.addPhoneContact({
       firstName: '张三',
       nickname:'zs',
       remark:'程序员',
       mobilePhoneNumber:'17788165236',
       email:'4464664@qq.com'
     })
     3:截屏功能
       wx.onUserCaptureScreen(function (res) {
        that.setData({
          con: '用户截屏了'
        })
      })
## 电量和拨打电话
    1:获取电量
      wx.getBatteryInfo({
        success(res){
          console.log(res);
          that.setData({
            battery:res.level-2,
            isCharging:res.isCharging
          })
        }
      })
    2:拨打电话
    wx.makePhoneCall({//拨打电话
      phoneNumber: phoneNUmber //电话号码
    })
## 手机倾斜感应
    开始建监听
     wx.startDeviceMotionListening({//开始监听
      success(e){
        console.log(e);
      }
    })
    结束监听
    wx.stopDeviceMotionListening({
          success(res){

          }
    })
    监听手机方位变化
     let that=this;
     wx.onDeviceMotionChange((res)=>{
       let alpha = parseFloat(res.alpha);
       if (alpha > 45 && alpha < 136) {
         screen = '左侧'
       }
       else if (alpha > 225 && alpha < 316) {
         screen = '右侧'
       }
       else if (alpha > 135 && alpha < 226) {
         screen = '反面'
       } else {
         screen = '证明';
       }
       that.setData({
         screen: screen,
         alpha: alpha
       })
     })
## 动态设置导航和用户交互
    1:设置导航
         wx.showNavigationBarLoading();//显示加载动画
        wx.setNavigationBarTitle({//设置标题
          title: '用户正在输入'
        })
        setTimeout(()=>{
          wx.setNavigationBarTitle({
            title: '我的微信' //设置标题
          })
          that.setData({
            showcon:'新内容'
          })
          wx.hideNavigationBarLoading();//隐藏加载动画
     },3000)
     2:用户交互
      /**
        * 消息提示框
        * icon:sucess,loading,none
        * images:自定义图片
        * mask:是否有透明层,防止触摸穿透
        */
       showtoast(){
         wx.showToast({
           title:'操作确认',
           icon:'success',
           images:'',
           duration:3000,
           mask:false,
           success(res){
             console.log(res);
           },
           fail(err){
             console.log(err);
           },
           complete(com){
             console.log(com);
           }
         })
       },
       /***
        * 模态框
        * showcanel,是否显示确定取消按钮
        * cancelText返回文本按钮
        */
       showmodule(){
         wx.showModal({
           title: '提示',
           content: '确定需要删除吗?',
           showCancel:true,
           cancelColor:'red',
           cancelText:'返回',
           confirmColor:'green',
           confirmText:'下一步',
           success(res) {
             console.log(res);
           },
           fail(err) {
             console.log(err);
           },
           complete(com) {
             console.log(com);
           }
         })
       },
       /***
        * 加载层
        * mask:后面元素无法操作
        */
       showloading(){
         wx.showLoading({
           title: '数据正在查询',
           mask:true,
           success(res) {
             console.log(res);
           },
           fail(err) {
             console.log(err);
           },
           complete(com) {
             console.log(com);
           }
         })
         setTimeout(()=>{
           wx.hideLoading({
             success(res) {
               console.log(res);
             },
             fail(err) {
               console.log(err);
             },
             complete(com) {
               console.log(com);
             }
           })
         },3000)
       },
       /***
        * 显示操作菜单
        */
       showactionsheet(){
         let  path='';
         wx.showActionSheet({
           itemList: this.menuList,
           itemColor:'#ccc',
           success(res) {
             console.log(res);
             switch(res.tapIndex){
               case 0:
               path='school';
               break;
               case 1:
                 path = '/pages/index/index';
                 break;
               case 2:
                 path = 'school';
                 break;
               case 3:
                 path = 'school';
                 break;
             }
             wx.redirectTo({
               url: path,
             })
           },
           fail(err) {
             console.log(err);
           },
           complete(com) {
             console.log(com);
           }
         })
       }
## 导航栏设置
    1:动态导航栏标题
       wx.setTopBarText({
         text: '小程序置顶显示',
          success(res){
              console.log(res);
          },
          fail(err){
            console.log(err);
          }
       })
    2:设置导航栏背景
     wx.setBackgroundColor({ //开启下拉刷新可以看到效果
          // backgroundColor:'#ff0000', //十六进制必须要写全,简写
          backgroundColorTop:'#00ff00',
          backgroundColorBottom:'#0000ff'
        }}
## 动态设置tabbar操作
    1:data
     data: {
        count:5,
        i:'123'
      }

    2:
     /**
       * 动态改变tabbar
       */
      setItem(){
        wx.setTabBarItem({//设置对应的tabbar
          index: 0,//对应tabbar的设置
          text:'测试'//设置文字
        })
      },
      /***
       * 显示红色角标
       */
      setRedDot(){
        wx.showTabBarRedDot({//这是红色角标
          index: 1 //index对应tabbar的设置
        })
        setTimeout(()=>{
          wx.hideTabBarRedDot({//隐藏红色角标
            index: 1,
          })
        },2000)
      },
      /***
       * 数字角标
       */
      showBage(){
        wx.setTabBarBadge({
          index: 0,//tabar的对应的值
          text: '3'
        });
        setTimeout(()=>{
          wx.removeTabBarBadge({//移出数字角标
            index: 0
          });
        },3000)
      },
      /**
       * 设置闪动红色角标 需要注意的是,count的值不能太大,不然会导致跳转到页面后,角标还在闪动
       */
      flashDot(){
        let that=this;
        let count=this.data.count;
        if(that.data.i!=null){
            that.setData({
              timer:setInterval(()=>{
                count--;
                //求余数,偶数显示,奇数不显示
                if(count%2==0){
                  wx.showTabBarRedDot({
                    index: 1
                  })
                }else{
                  wx.hideTabBarRedDot({
                    index: 1
                  })
                }
                if(count==0){
                  clearInterval(that.data.timer);
                }
              },500)
            })
        }
      }
## 小程序返回顶部两种操作
    1:onPageScroll //周期函数
        设置返回按钮的显示/隐藏
          onPageScroll(e){
            let srollTop=e.scrollTop;
            if (srollTop>100){
                this.setData({
                  ishide:true
                })
            }
            else{
              if (srollTop < 60) {
                this.setData({
                  ishide: false
                })
              }
            }
        }
        返回顶部操作
        goTop(e){
            if(wx.pageScrollTo){
              wx.pageScrollTo({
                scrollTop: 0,
              })
            }else{
              wx.showModal({
                title: '提示',
                content: '当前微信版本过低,暂无法使用此功能',
              })
            }
         }
     2:scroll-view 组件
        1:组件属性设置
            scroll-y:开启纵向滚动
            scrollTop:到顶部的距离,
            bindscroll:滚动的时候触发的方法
           <scroll-view  scroll-y style="height:1400rpx" scrollTop="{{top}}"
            bindscroll="toTop">
            设置按钮显示/隐藏
            toTop(e){
                let  top=e.detail.scrollTop;
                if(top>600){
                  this.setData({
                    ishide:false
                  })
                }else{
                  this.setData({
                    ishide: true
                  })
                }
            }
            返回顶部操作
             this.setData({
                    top:0
             })
## 原生动画
    1:设置组件的动画对象animation="{{obj}"
    <view class="view" animation="{{animate}}"> </view>
    /***
       * 移动方法
       */
      move(){
        //声明动画对象
        let anmiObj=wx.createAnimation({//创建动画对象,设置动画参数
          duration:400,
          timingFunction:'ease',
          delay:0
        })
        //设置动画效果
        anmiObj.translateX(200).backgroundColor('#00ff00').width(200).opacity(0.19).step();//设置动画的具体内容
        this.setData({
          animate:anmiObj.export() //到处动画给组件设置的动画对象
        })
      }
## 小程序刷新操作
    1:下拉刷新
    开启下来刷新,需要在当前页面的配置文件中配置
    "enablePullDownRefresh": true,
    onPullDownRefresh(){//周期函数,
        console.log('每次下来的时候都会触发这个时间');
    }
    2:上触底刷新
      //页面滚动到底部会触发该事件
      onReachBottom: function () {
        console.log('到底部了');
      }
    3:自定义刷新操作 借助scoll-view组件
          <!-- 垂直滚动在scroll-view空间中需要定义高度height-->
          scroll-y:开始纵向滚动
          bindscrolltolower:页面滚动到底部会触发该事件,
          bindscrolltoupper:滚动到顶部会触发该事件
          bindscroll:滚动的时候触发该事件
          <scroll-view scroll-y style='height:{{scrollHeight}}px' class='list' bindscrolltolower='bindDownLoad' bindscrolltoupper='topLoad' bindscroll='scroll'>
## 菜单, 窗口,键盘事件
    1:分享按钮的位置,大小信息,
        let data=wx.getMenuButtonBoundingClientRect();
        console.log(data);
    2:键盘事件
      //键盘高度监控
        wx.onKeyboardHeightChange((res)=>{
          console.log(res);
        })
    3:窗口变化事件
       //屏幕监控,主要是屏幕的旋转
       wx.onWindowResize((res)=>{
         console.log(res);
       })
##  登录状态,获取用户信息
    /**
      * wx登录
      */
     wxlogin(){
       wx.login({
         success(res) {
           console.log(res.code);
           //向公司的服务器发送请求
           wx.request({
             url: 'www.uguoba.con/requestapi',//公司后台接口
             data: { code: res.code },
             success(res) {
               console.log(res);
               let openID = res.openID;
               let sessionKey = res.sessionKey;
               //存储storage
               wx.setStorage({
                 key: 'userinfo',
                 data: {
                   openID: openID,
                   sessionKey: sessionKey
                 }
               })
             },
             fail(err) {
               console.log('err', err);
             }
           })
         }
       })
     },
     /***
      * 登录
      */
     login(e){
      this.wxlogin();
     },
     /***
      * 获取公司信息
      */
     getComInfo(){
       //从缓存中获取用户登录状态
       wx.getStorage({
         key: 'userinfo',
         success: function(res) {
           //向服务器发送数据,获取数据
           let openId=res.openID;
           let sessionKey=res.sessionKey;
           //验证登录状态sessionkey是否失效(服务器删除)
           wx.checkSession({
             success(){
               this.send();
             },
             fail(){
               //重新登录
               this.wxlogin();
             }
           })

         },
       })

     },
     /***
      * 向服务器发送数据
      */
     send(){
       wx.request({
         url: 'www.uguoba.con/comapi',
         data: {
           openID: openId,
           sessionKey: sessionKey
         },
         success(res) {
           //处理服务器返回数据
         }
       })
     },
     /**
      * 获取账号信息
      */
     getAccountInfo(){
       const accountInfo = wx.getAccountInfoSync();
       console.log(accountInfo);
     },
     /***
      * 获取用户信息
      */
     getUserInfo(){
       wx.getUserInfo({
         success(res){
           console.log(res);
         },
         fail(res){
           console.log(res);
         }
       })
     }
##  小程序之间的跳转,小程序的数据上报和数据分析
    1:小程跳转
       1:wx.navigateBackMiniProgram 小程序返回
       2:需要在app.json里面配置小程序的跳转的小程序列表
         "navigateToMiniProgramAppIdList":[
            "wx51441ba03f4b09f2"
          ]

        3:跳转
         wx.navigateToMiniProgram({//最大数量10
          appId:'wx51441ba03f4b09f2',//要跳转的小程序的id
          path:'pages/index/index?id=5646',//默认打开的路径,可以带参数
          extraData:{//其他的参数
            foor:'bar',
          },
          envVersion:'develop',//跳转的版本,开发本,上线版,体验版
          success(res){
            console.log(res);
          },
          fail(err){
            console.log(err);
          }
        })
    2:实时上报
        1:在微信公众平台的 开发=>性能监控=>新建自定义指标数据
        2:数据上报
             wx.reportMonitor('0',10);//0是自定义指标数的id,10是监控的值
    3:数据分析
        1:在微信公众平台 统计=>自定义分析=>新建事件
        2:数据分析,
         wx.reportAnalytics('user', {//上传的数据,数据格式是在微信公众平台上设置的
              nam:'zhangsan',
              age:'20'
         })
##  小程序 支付,授权,广告
     /***
       * 1:必须是认证过的
       * 2:必须是企业的微信号
       * 3:小程序必须开通了支付功能
       * 4:必须和公司的服务器相联系
       * 5:和后端签名保持一致
       *
       */
      payMent(){
          wx.requestPayment({//发起支付
            timeStamp: '',
            nonceStr: '',
            package: '',
            signType: '',
            paySign: '',
          })
      },
      /***
       * 授权
       */
      setAuth(){
        wx.getSetting({
          success(res){
            if(!res.authSetting["scope.record"]){//判断是否开启录音功能,
              wx.authorize({
                scope: 'scope.record',
                success(){
                  wx.srartRecord();//开启录音功能
                }
              })
            }
          }
        })
      },
      /***
       * 广告
       * 在微信公众平台设置推广,广告组
       * banner广告,自己的广告
       * 视频广告,插屏广告,别人在你这边的广告
       */
##  小程序系统设置,收货地址
     /***
       * 收货地址
       */
      address(){
        wx.chooseAddress({
          success(res){
            console.log(res);
          }
        })
      },
      /***
       * 系统设置
       */
      setSys(){
        let list=[];
        let that=this;
        wx.openSetting({
          success(res){
            console.log(res);
            let obj=[
              {
                name: '地址',
                value: res.authSetting['scope.address']
              },
              {
                name: '摄像',
                value: res.authSetting['scope.camera']
              },
              {
                name: '录音',
                value: res.authSetting['scope.record']
              },
              {
                name: '用户授权信息',
                value: res.authSetting['scope.userInfo']
              },
              {
                name: '保存相册',
                value: res.authSetting['scope.writePhotoAlbum']
              }
            ]
            that.setData({
              opList:obj,
              shows:false
            })
          }
        })
      },
      /***
       * 查看授权列表
       */
      userAuth(){
        wx.getSetting({
          suceess(res) {
            console.log(res);
          }
        })
      }
##  小城程当先位置和发票
     /**
       * 获取地理位置
       */
      app.json配置
      "permission": {
          "scope.userLocation": {
            "desc": "获取位置信息将用户小程序"
          }
        }
      getLocation(){
        let  that=this;
        wx.getLocation({//需要在app.json里面配置信息
          type:'wgs84',
          success: function(res) {
            console.log(res);
            wx.request({
              url: 'http://api.go2map.com/engine/api/regeocoder/json?points='+res.longitude+','+res.latitude+'&type=1',
              success(res){
                console.log(res.data.response.data[0]);
                that.setData({
                  longitude: res.data.response.data[0].x,
                  latitude: res.data.response.data[0].y
                })
              }
            })
          },
        })
      },
      /**
       *获取发票抬头信息
       */
      getInvoiceTtitle(){
        let that=this;
        //获取发票抬头
        wx.chooseInvoiceTitle({
          success(res){
            console.log(res);
            that.setData({
              bankName: res.bankName
            })
          },
          fail(err){
            console.log(err);
          }
        })
      },
      /***
       * 获取发票信息
       */
      getInvoice(){
        console.log('e');
        wx.chooseInvoice({
          success(res){
            console.log(res);
          }
        })
      }
##  微信运动和分享
       1:运动,需要关注微信运动公众号和认证
      sport(){
        wx.getWeRunData({
          success(res){
            console.log(res);
          },
          fail(err){
            console.log(err);
          }
        })
      }
    2:分享:
        1:组件触发
          <button open-type="share"  type="primary">手动转发</button> 触发的是微信的分享组件 也是onShareAppMessage函数
        2:右上角分享触发 触发的是 onShareAppMessage 函数
        onShareAppMessage: function () {
             /**
              * title:标题
              *path:转发后的页面
              *imgUrl:自定义的图片路径
              */
              return {
                title:'清凉暑假亲自游玩记',
                path:'/pages/index/index',
                imageUrl:'http://img.sccnn.com/bimg/337/6624.jpg'
              }
          }

## 打电话,验证码,短息验证码
   1:打电话:
     wx.makePhoneCall({
          phoneNumber: this.phone,
          success(res){
            console.log('success',res)
          },
          fail(res){
            console.log('fail',res)
          }
      })
   2:验证码信息验证
       见例子:SmallProgramTelMsgValidcode
## 多线程和wxml
    1:worker 在page同一级的创建文件夹,文件夹里面建立js文件myworkers.js,
        app.json配置:
        "workers": "workers",
      1:主线程:
        /***
           * 触发主线程
           */
          touch(e){
            console.log(e);
            let that=this;
            let num1=e.detail.value.num1;
            let num2 = e.detail.value.num2;
            if(num1==''||num2==''){
              wx.showModal({
                title: '数据异常',
                content: '请检查输入的数据'
              })
              return ;
            }
            //创建worke线程对象
            const worker=wx.createWorker('/workers/myworkers.js');
            //发送数据
            worker.postMessage({
              x:num1,
              y:num2
            })
            //监控
            worker.onMessage((res)=>{
              console.log('这是主线程的onMessag对象',res);
              that.setData({
                result:res.sum
              })
            })
         2:子线程
           /***
            * 在worker线程中,会自动创建一盒worker对象,可以直接使用
            */
           //监听主线程的诗句
           worker.onMessage((res)=>{
             console.log('这时候worker内部线程打印的数据');
             let x=res.x;
             let y=res.y;
             let sum=add(x,y);
             //发送数据回到主线程
             worker.postMessage({
               sum:sum
             })
           })
           /***
            * 求和操作
            */
           function add (x,y){
             return parseInt(x)+parseInt(y);
           }
     2:wxml
       //创建对象
       const query=wx.createSelectorQuery();
       //绑定指定的区块
       query.select('#myid').boundingClientRect();//#myid元素的id
       query.selectViewport().scrollOffset();
       //执行
       query.exec((res)=>{
         console.log(res);//元素的相关信息
       })
# 事件
    catchtap,bindtap
    catchtap:阻止冒泡事件 (从内向外)
    bindtap:不阻止冒泡事件
    capture:tap: 捕获事件 (从外向内)
# 通过属性给方法传值
     <view class="{{classArr[index]}}" data-index="{{index}}" bindtap="changeActive">{{item.title}}</view> //data-index="{{index}}" index是要传递的值
     在bindtap函数里面通过 event.currentTarget.dataset.index来接收

#  小程序组件
    1:组件内的样式文件,不能使用 id选择器,属性选择器,标签选择,只能使用类名选择器
    2:页面引用自定义组件
       1:在当前页面的json配置文件中添加
       2:"usingComponents": {
           "myWelcome":"/components/welcome/welcome"
         }
       3:页面上引用
       <myWelcome> </myWelcome>
    3:组件引用组件
        1:在当前组件的json配置文件中添加配置信息
        2:"usingComponents": { //此处用法和页面引用组件的用法一样
           "my-form": "/components/form/form"
          }
        3:组件内使用
         <my-form></my-form>
# slot 插槽的使用
    1:插槽是一个占位符,首先占个位置,等待数据填充
    2:使用
        1:声明插槽
            <slot></slot>
        2:当页面中有多个插槽的话,
            1:需要添加name属性进行区分;
            2:需要在有插槽组件的js文件中添加配置信息
            options:{
                multipleSlots:true //允许使用多个插槽
              },
         <view>
           <view class="nav">
               <view>首页</view>
               <view>>></view>
               <slot name="nav"></slot>
           </view>
           <view class="page">
               <slot name="des"></slot>
           </view>
         </view>
    3:给插槽赋值
       <view>
         <myWelcome>
           <view slot="nav">购物</view> //此处内容传递给name是nav的插槽
         </myWelcome>
           <myWelcome>
           <view slot="des">狂欢购物的天堂</view> //此处内容传递给name是des的插槽
         </myWelcome>
       </view>
# 其它
  1:组件的隔离样式,组件的内部样式,不收外部样式的影响
    :host{
        color:red;
        font-size:30rpx;
    }
  2:组件默认的样式是隔离的,不会受到的其它wxss样式影响
  3:样式隔离配置
    在组件的配置文件中,添加
    1:isolated:默认值
       启用样式隔离,在自定义组件的内外,使用class指定的样式不会相互影响
    2:apply-shared
       页面的wxss样式会影响到自定义组件的wxss中的样式,但自定影组件中的样式不会影响到页面的wxss
    3:shared
       页面的wxss样式会影响到自定义组件样式,自定义组件的wxss样式也会影响到页面的样式和其它设置了
       app-shared和shared的自定义组件(但是不会影响插件)
    options:{
        multipleSlots:true, //允许使用多个插槽
        stylelsolation:'isolated'
      }
  4:使用父页面指定样式
    1:在组件的js文件里面添加配置
      externalClasses:['fontColor'],里面是指定要使用那些父页面的样式多个用,分开
    2:父页面上传递进来类名
     <myWelcome my-class="fontColor"></myWelcome>
    3:组件内使用样式
      <view class="fontColor"></view>//使用父页面传递进来的样式


