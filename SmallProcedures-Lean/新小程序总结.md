#  新版小程序总结
## 全局配置文件app.json和底部导航配置
{
  "pages": [ 所有的页面都应该在这里书写
    "pages/index/index",
    "pages/logs/logs"
  ],
  "window": {
    "backgroundTextStyle": "light",下来刷新的时候,背景里面的,里面的文字的背景色
    "navigationBarBackgroundColor": "#000",顶部导航栏的背景色
    "navigationBarTitleText": "我的微信",页面的标题
    "navigationBarTextStyle": "white",页面标题的文字颜色
    "enablePullDownRefresh": true,开启下拉刷新
    "backgroundColor": "#ddd" 下拉刷新的时候,背景的颜色
  },
  "sitemapLocation": "sitemap.json" 是否允许小程序被搜索到,可以在sitemap.json里面配置到那些页面会被搜索到或者不会被搜索到
}
## 每一个页面里面的json
页面的json只配置window里面的内容,优先级高于全局配置,配置的时候默认就是window不需要家window的键
    {
      "navigationBarTitleText": "查看启动日志",
      "usingComponents": {}
    }
## 底部导航栏
    将跳转的连接放在tobBar里面,也上原有的连接将会失效
     "tabBar": {
        "list": [{
          "pagePath": ""pages/index/index",
          "text": "首页",
          "iconPath": "iconPath",按钮默认图标
          "selectedIconPath": "selectedIconPath" 按钮选中后的图标
        },
        {
                   "pagePath": "pages/logs/logs",
                   "text": "日志",
                   "iconPath": "iconPath",
                   "selectedIconPath": "selectedIconPath"
                 }
        ]
      }
## 页面分析
    wxml->html 不能直接使用html的标签
    wxss->css  兼容所有的css的样式
    js-> 微信小程序js里面是不能使用dom对象的,不存在windows对象,只是使用了js的核心语法

    <text> font+span 行内元素
    view   div  块级元素

    信息提示框
    wx.showToast({
        title:'这是提示框'
    })
## 页面声明周期函数
    onLanuch: 在app.js里面小程序在打开那一刻,首先触发的函数
    onLoad > onReady > onShow=onShow > onUnload页面卸载的时候
    onShareAppMessage 在分享之前就已经触发了
## swiper组件使用
     curent:默认显示的第几场图片(不仅仅是是图片,还可以是是页面)
     bindchange: 滚动改变的时候触发的事件
     autoplay:页面加载后自动滚动
     interval:页面加载多久后自动滚动
     duration:两张图片滚动的时间间隔
     circular:无缝滚动
     indicator-dots:是否出现焦点
     vertical:true 竖向滚动,(竖向滚动必须要给swiper一个高度)
     以上是一部分
     <swiper current="1" bindchange="changeCurrent" autoplay interval="2000" duration="700" circular indicator-dots>
        <swiper-item>
          <navigator url="/pages/about/about">
            <image src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571130748624&di=cf3b9e291be38dc5af4d9624bfd85951&imgtype=0&src=http%3A%2F%2Fpic2.16pic.com%2F00%2F01%2F24%2F16pic_124090_b.jpg" ></image>
          </navigator>
        </swiper-item>
        <swiper-item>
          <navigator>
            <image src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571130748624&di=fc52dc00493f3882484a2cb1dceff445&imgtype=0&src=http%3A%2F%2Fpic.baike.soso.com%2Fp%2F20100505%2F20100505154727-2016523917.jpg"></image>
          </navigator>
        </swiper-item>
     </swiper>
## scroll-view
    scroll-x:横向滚动
    里面的每一项需要自己设置横向排列
    <scroll-view scroll-x>
      <view class="view-container">
          <view class="view-con">
            <image src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571130748624&di=fc52dc00493f3882484a2cb1dceff445&imgtype=0&src=http%3A%2F%2Fpic.baike.soso.com%2Fp%2F20100505%2F20100505154727-2016523917.jpg" class="img"></image>
            <view>
              <view class="news-title">学习标题01</view>
              <text class="fnt-content">微信课程,滑块学习</text>
            </view>
          </view>
            <view class="view-con">
              <image src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571130748624&di=fc52dc00493f3882484a2cb1dceff445&imgtype=0&src=http%3A%2F%2Fpic.baike.soso.com%2Fp%2F20100505%2F20100505154727-2016523917.jpg" class="img"></image>
              <view>
                <view class="news-title">学习标题02</view>
                <text class="fnt-content">微信课程,滑块学习</text>
              </view>
            </view>
      </view>
    </scroll-view>
##  audio 组件 api的形式
    const myAudio=wx.createInnerAudioContext();创建音频对象
    myAudio.play();//播放音频
    myAudio.pause();//暂停音频
    myAudio.seek(12);跳转到指定的秒数
##  video 组件
     <video id="muvideo" enable-danmu danmu-list="{{danmulist}}" controls danmu-btn class="video"  src="{{src}}"></video>
     //enable-danmu :是否开启弹幕,danmu-list:弹幕列表 controls:开启按钮 danmu-btn :开启关闭弹幕按钮
     getVideo(){
         let that=this;
         wx.chooseVideo({ //微信api选择视频
           sourceTpye:['camera','album'],//视频来源,照相机拍摄或者相册
           maxDuration:60,//视频最长时间
           camera:['front','back'],//开启,前后摄像头
           success(res){
             that.setData({
               src: res.tempFilePath
             })
           }
         })
       }
     创建视频对象:this.videoContext = wx.createVideoContext('muvideo', this) muvideo视频组装件id
     发送弹幕:
     this.videoContext.sendDanmu({//视频独享,发送弹幕方法
           text:this.inputVlue,
           color:randomColor() //随机字体颜色
      })
    function randomCOlor(){
      let rgb=[];
      for(let i=0;i<3;i++){
        let color=Math.floor(Math.random()*256).toString(16);
        color=color.length==1 ? '0'+color:color;
        rgb.push(color);
      }
      return '#'+rgb.join('');
    }
## 移动
    movable-arae:移动区域
    movable-view:移动元素
            direction:'all' //全方位移动
            direction:'vertical' //水平方向移动
            direction: 'horizontal' //竖直方向移动
            direction: 'none' //不移动,配合x,y可以固定view的位置
            x:x轴的起始位置
            y:y轴的起始位置
    <view>全方位移动</view>
    <movable-area class="area">
        <movable-view direction='all' class="view"></movable-view>
    </movable-area>
    <view>在一个area里面多个view移动</view>

    <movable-area class="area">
        <movable-view direction='horizontal' class="view red"></movable-view>
        <movable-view direction='vertical' class="view yellow"></movable-view>
    </movable-area>
    <view>固定位置</view>
    <view>设置x,y坐标 ditection 为null</view>
    <movable-area class="area">
        <movable-view direction='none' x='50rpx' y="50rpx" class="view"></movable-view>
    </movable-area>
## 微信上面你的弹性布局
    display:flex;
    flex-direction:row/column;//主轴方向
    justify-content:flex-start/flex-end/center/space-round
    flex-wrap:wrap/nowrap //是否换行
    align-items:flex-star/flex-end;center;
## wx:for
    wx:for里面的wx:key可以对循环渲染起到性能优化作用,有wx:key的时候,会根据wx:key进行渲染,没有的话,则需要循环整个数据
    wx:if,hidden:
        wx:if 条件不成立的时候,则不会渲染数据
        hidden hidden只是元素不显示,但是元素还会被渲染
    template,block
        template 作为模板使用,一般不希望现实tempate的标签,模板的高级用法,可以在外面单独建立模板文件引入,模块化开发
        block 作为对代码片段的控制
    template 用法的例子
              template 作为引入模板,再引入其它模板的话,容易混乱
            <!-- 一般用法 -->
            <template name="studentInfo">
              <view>
                姓名:{{student.name}}
              </view>
              <view>
                年龄:{{student.age}}
              </view>
            </template>
            <template is="studentInfo" data="{{student}}" />
            <!-- 解构用法 -->
            <template name="studentInfo1">
              <view>
                姓名:{{name}}
              </view>
              <view>
                年龄:{{age}}
              </view>
            </template>
            <template is="studentInfo1" data="{{...student}}" />
            <!-- 一般用法 -->
            <template name="studentInfo2">
              <block wx:for="{{stuArr}}" wx:key="{{item}}">
                <view>
                  姓名:{{item.name}}02
                </view>
                <view>
                  年龄:{{item.age}}02
                </view>
              </block>
            </template>
            <template is="studentInfo2" data="{{stuArr}}" />

            <!-- 循环模板用法 -->
            <template name="studentInfo3">
                <view>
                  姓名:{{item.name}}
                </view>
                <view>
                  年龄:{{item.age}}
                </view>
            </template>
            <view  wx:for="{{stuArr}}" wx:key="{{item}}">
              <template is="studentInfo3" data="{{item}}" />
            </view>
            <!-- 解构用法 -->
            <template name="studentInfo4">
                <view>
                  姓名:{{name}}
                </view>
                <view>
                  年龄:{{age}}
                </view>
            </template>
            <view  wx:for="{{stuArr}}" wx:key="{{item}}">
              <template is="studentInfo4" data="{{...item}}" />
            </view>


            <!-- 引用模板 -->
            <import src="/template/studentInfo.wxml"/>

            <!-- 使用模板 -->
            <view  wx:for="{{stuArr}}" wx:key="{{item}}">
              <template is="studentInfo5" data="{{...item}}" />
            </view>
            <!--引入模板 -->
            <!-- 包含模板里面不可有template模板 -->
            <include src="/template/include.wxml" />

            引入的两个模板
            include.wxml
                <view>
                  我这边是包含模板
                </view>
            studentInfo.wxml
             <template name="studentInfo5">
                 <view>
                   姓名:{{name}} 我是外面引入的模板
                 </view>
                 <view>
                   年龄:{{age}} 我是外面引入额模板
                 </view>
             </template>
#richtext 和progress
    richtext:
        nodes:可以是字符串,自古穿里面可以有标签,也可以是数组,数组的时候,要按照一定的格式
        <view>
          <view>富文本编辑器 nodes=strings</view>
          <rich-text nodes="{{strings}}"></rich-text>
        </view>
        strings:'<h1>这是富文本编辑器</h1>',
        <view>
          <view>富文本编辑器 nodes=array</view>
          <rich-text nodes="{{nodesArr}}"></rich-text>
        </view>
        nodesArr:[
                      {
                        name: 'h4',
                        attrs:{
                          style:'color:red;'
                        },
                        children:[
                          {
                            type:'text',
                            text:'子节点标题'
                          }
                        ]
                      }
        ]

        process:
        percent:开始的时候的比例
        stroke-width:进度条的高度
        color:进度条的颜色
        active:是否开启动画
        show-info:是否在进度条右侧显示百分比
        <progress percent="100" show-info stroke-width="14" color="pink" active="true" >
         <view class="title-line">procress</view> //此处的文字会出现在百分比的后面
        </progress>
##  from 小程序的所有的提交上都是异步的
        bindsubmit:提交的时候触发,formSubmit后台定义的方法
        bindreset:数据重置的时候触发,formReset后台的定义方法
        from-type:属性必须要写,后面的form-type的属性,是固定的submit,reset方法
        <form bindsubmit="formSubmit" bindreset="formReset">
        <input name="userName"></input> 只有有name属性,后台才能收到的值
            <button form-type="submit">Submit</button>
            <button form-type="reset">Reset</button>
        </form>
## input
        <input confirm-type="search"></input>
        <input placeholder="name" maxlength="" focus placeholder-style="color:red"  bindinput="inputBind" bindfocus="getFocus" bindblur="blur" bindconfirm="confirm" placeholder-class="bg"></input>
        confirm-type:search,//键盘右下角的文字, send,next,go,done
##  checkbox
      <view>checkbox</view>
      <checkbox-group bindchange='checkbind'> 一组checkbox里面的改变都会触发checkbind方法
        <checkbox value="1011">1011</checkbox>
        <checkbox value="1012" checked>1012</checkbox>
      </checkbox-group>
       <checkbox-group  bindchange="checkChange">
        <label wx:for="{{items}}" wx:key="{{index}}">
          <checkbox value="{{item.name}}" checked="{{item.checked}}">{{item.name}}</checkbox>
        </label>
      </checkbox-group>
      <view>editor</view>
      showImgToolbar:显示图片上传按钮
      showImgSize:显示图片大小
      showImgResize:开启图片可缩放
      bindstatuschange:监听edirtor的变化
      <editor placeholder="this is a editor" id="editor" showImgToolbar showImgSize showImgResize  bindstatuschange="statusChange"></editor>
      <view>radio</view>
      <radio-group bindchange='radioChange'> 一组radiobox里面的改变都会触发radiobox方法
        <view wx:for="{{radioArr}}"  wx:key="{{index}}">
            <label for="{{item.name}}">点赞</label>
            <radio id="{{item.name}}" value="{{item.name}}" name="{{item.name}}" checked="{{item.checked}}">{{item.value}}</radio>
        </view>
      </radio-group>
## picker
        //所有数据变化都在事件的e里面
        //mode 类型 selector:单行选择,multiSelector:多列选择,time:时间选择,date:日期选择,city:城市选择
        //value:默认值
        //range:数据来源 city的数据源由微信小程序自动提供
        //数据的变化都在绑定事件的e参数里面
         data: {
            city:['','',''],
            date:'',
            time:'',
            multiIndex:[0,0,0],
            index:0,
            multiArray:[
              ['中国','北京'],
              ['美国','纽约'],
              ['日本','大阪'],
              ['英国','伦敦','开普勒']
            ],
            country: ['中国','美国','日本','英国'],
            radioArr:[
              {name:'top',checked:false,value:'top'},
              { name: 'tom', checked: false, value: 'tom' },
              { name: 'lily', checked: true, value: 'lily' },
              { name: 'judy', checked: false, value: 'judy' }
            ],
            items:[
              {
                name:'top',value:'CHA'
              },
              {
                name: 'alis', value: 'CHA'
              },
              {
                name: 'tom', value: 'CHA',checked:true
              },
              {
                name: 'lyly', value: 'CHA'
              }

            ]
          }
      <view>picker</view>
      <picker bindchange="pickChange" mode="selector" value="{{index}}" range="{{country}}">
        <view>当前选择:{{country[index]}}</view>
      </picker>
      <view>多列选择器:</view>
      <picker mode="multiSelector" bindchange="multiChange" bindcolumnchange="coloumnChange" value='{{multiIndex}}' range="{{multiArray}}" >
        <view>当前选择:{{multiArray[0][multiIndex[0]]}}</view>
      </picker>
      <view>时间</view>
      <picker mode='time' start='09:00' end="21:00" bindchange="timeChange" >
        <view>当前时间:{{time}}</view>
      </picker>
      <picker mode='date' start='2015-09-10' end='2100-09-10' bindchange="dateChange">
          <view>当前日期:{{date}}</view>
      </picker>
      <view>省市选择</view>
      <picker mode='region' bindchange="cityChange">
        <view>当前选择:{{city}}</view>
      </picker>
     <view>slide滑动选择器</view>
     <view>设置step</view>
     step:每一步滑动距离的
     show-value:显示数值
     min:最小值
     max:最大值
     <slider step="5" bindchange="slideChane" show-value min="50" max="200"></slider>
      <view>switch</view>
     <switch bindchange="switchChange"></switch>
     <switch checked bindchange="switchChange"></switch>
     <view>textarea</view>
     <view>
        auto-height:根据输入内容自动的高度
        auto-focus:获取焦点的时候,自动弹出键盘
       <textarea value="this is textarea" bindblur="areaChange" auto-height auto-focus="true"></textarea>
     </view>
##  导航
        组件跳转
        <navigator target="self" url="/pages/about/about" open-type="redirect">跳转操作redirect</navigator>//跳转以后,无法返回
        <navigator target="self" url="/pages/about/about" open-type="navigate">跳转操作navigate</navigator>//跳转以后,其它打开的页面还是打开的
        <navigator target="self" url="/pages/about/about" open-type="switchTab">跳转操作switchTab</navigator>//需要后台的支持,url的页面,必须在app.json的tapbar里面配置的页面,才能跳转
        <navigator target="self" url="/pages/about/about" open-type="reLauunch">跳转操作reLauunch</navigator>//跳转以后,关闭其它已经打开所有页面
        <navigator target="self" url="/pages/about/about" open-type="navigateBack">跳转操作navigateBack</navigator>//打开页面以后,可以通过这个按钮回退
        <navigator target="miniProgram"  open-type="exit">小程序调换</navigator>//跳转到新的小程序,关闭当前小程序,ios不支持
        微信接口跳转
         wx.switchTab({//只能跳转到tabar里面设置过的页面
              url: '/pages/usercenterDemo/usercenterDemo',
         })
         wx.redirectTo({//不能跳转到tabar里面设置过的页面
           url: '/pages/moveableDemo/moveableDemo',
         })
         wx.reLaunch({//不能跳转到tabar里面设置过的页面
           url: '/pages/moveableDemo/moveableDemo',
         })
         wx.navigateTo({ //不能跳转到tabar里面设置过的页面
           url: '/pages/moveableDemo/moveableDemo',
         })
         wx.navigateBack({//不能跳转到tabar里面设置过的页面
           url: '/pages/moveableDemo/moveableDemo'
         })
## camera
        device-position:'front/back'默认打开的是前置摄像头,还是后置摄像头
        flash:off/on;是否开启闪光灯
          <camera class="camera-cls" device-position="front" flash="off"  >
            <cover-view class="main-tips">photo</cover-view>//覆盖在照相机上面的文字
            <cover-image class="cover-img" src="/image/rx.png"></cover-image>//覆盖在照相机上面的图片
            <cover-image class="hd" bindtap="takePhoto" src="/image/hd.png"></cover-image>//按下拍照后触发的事件
         </camera>
         takePhoto(){
             const ctx=wx.createCameraContext(this);//创建camera对象
             ctx.takePhoto({
               quality:'high',//照片质量
               success:(res)=>{//拍摄成功后的回调函数
                 //设定到缓存
                 wx.setStorage({//放入缓存
                   key: 'photoPeople',
                   data: res.tempImagePath
                 })
                 wx.redirectTo({//页面跳转
                   url: '/pages/caneraDemo/photo'
                 })
               }
             })
           }
#   map组件
        latitude:地图中心点的纬度
        longitude:地图中心的的经度
        markers:标记点
        cover:覆盖点
        show-location:显示带有方向的当前定位点
        <map id="mymap" style="width:100%;height:600rpx;"
                latitude="{{latitude}}"
                longitude="{{longitude}}"
                markers="{{markers}}"
                cover="{{covers}}"
                show-location
              ></map>
        data数据:
         data: {
            latitude:23.09994,
            longitude:113.234520,
            markers:[
              {
                id:1,
                latitude: 23.09994,
                longitude: 113.234520,
                name:'T创业园'
              }
            ],
            covers:[
              {
                latitude: 23.09994,
                longitude: 113.334520,
                iconPath:'/image/location.png'
              },
              {
                latitude: 23.09994,
                longitude: 113.304520,
                iconPath: '/image/location.png'
              }
            ]
         }
         部分API:
         创建地图对象:this.mapCtx=wx.createMapContext('mymap', this)
         获取中心的位置:
         this.mapCtx.getCenterLocation({
               success(res){
                       that.setData({
                         latitude:res.latitude,
                         longitude:res.longitude
                       })
                     }
         })
         移动位置 默认的是移动到你所在的位置
         this.mapCtx.moveToLocation();
         移动标注
          this.mapCtx.translateMarker({
             markerId:1,
             autoRotate:true,
             duration:2000,
             destination:{
               latitude:23.10339,
               longitude:113.3345211
             },
             animationEnd(){
               console.log('end');
             }
          })
         缩放地图
          this.mapCtx.includePoints({
           padding:[10],
           points:[
             {
               latitude: 23.10229,
               longitude: 113.3345211
             },
             {
               latitude: 23.00229,
               longitude: 113.3345211
             }
           ]
         })
#  canvas
           <!-- 同一个页面中canvas-id不可重复,如果过重复了将会隐藏不工作 -->
           disable-scroll:禁止下拉的时候,画布滚动
         <canvas
         canvas-id="myCanvas"
         class="myCanvas"
         disable-scroll="false"
         bindtouchstart="touchStart"
         bindtouchmove="touchMove"
         bindtouchend="touchEnd"
         ></canvas>
         ```
         Page({
           data: {
             pen: 3, //画笔粗细默认值
             color: '#000' //画笔颜色默认值
           },
           startX: 0, //保存X坐标轴变量
           startY: 0, //保存X坐标轴变量
           isClear: false, //是否启用橡皮擦标记
           //手指触摸动作开始
           touchStart: function (e) {
             //得到触摸点的坐标
             this.startX = e.changedTouches[0].x
             this.startY = e.changedTouches[0].y
             this.context = wx.createContext()

             if (this.isClear) { //判断是否启用的橡皮擦功能  ture表示清除  false表示画画
               this.context.setStrokeStyle('#F8F8F8') //设置线条样式 此处设置为画布的背景颜色  橡皮擦原理就是：利用擦过的地方被填充为画布的背景颜色一致 从而达到橡皮擦的效果
               this.context.setLineCap('round') //设置线条端点的样式
               this.context.setLineJoin('round') //设置两线相交处的样式
               this.context.setLineWidth(20) //设置线条宽度
               this.context.save();  //保存当前坐标轴的缩放、旋转、平移信息
               this.context.beginPath() //开始一个路径
               this.context.arc(this.startX, this.startY, 5, 0, 2 * Math.PI, true);  //添加一个弧形路径到当前路径，顺时针绘制  这里总共画了360度  也就是一个圆形
               this.context.fill();  //对当前路径进行填充
               this.context.restore();  //恢复之前保存过的坐标轴的缩放、旋转、平移信息
             } else {
               this.context.setStrokeStyle(this.data.color)
               this.context.setLineWidth(this.data.pen)
               this.context.setLineCap('round') // 让线条圆润
               this.context.beginPath()

             }
           },
           //手指触摸后移动
           touchMove: function (e) {
             var startX1 = e.changedTouches[0].x
             var startY1 = e.changedTouches[0].y

             if (this.isClear) { //判断是否启用的橡皮擦功能  ture表示清除  false表示画画

               this.context.save();  //保存当前坐标轴的缩放、旋转、平移信息
               this.context.moveTo(this.startX, this.startY);  //把路径移动到画布中的指定点，但不创建线条
               this.context.lineTo(startX1, startY1);  //添加一个新点，然后在画布中创建从该点到最后指定点的线条
               this.context.stroke();  //对当前路径进行描边
               this.context.restore()  //恢复之前保存过的坐标轴的缩放、旋转、平移信息

               this.startX = startX1;
               this.startY = startY1;

             } else {
               this.context.moveTo(this.startX, this.startY)
               this.context.lineTo(startX1, startY1)
               this.context.stroke()

               this.startX = startX1;
               this.startY = startY1;

             }
             //只是一个记录方法调用的容器，用于生成记录绘制行为的actions数组。context跟<canvas/>不存在对应关系，一个context生成画布的绘制动作数组可以应用于多个<canvas/>
             wx.drawCanvas({
               canvasId: 'myCanvas',
               reserve: true,
               actions: this.context.getActions() // 获取绘图动作数组
             })
           },
           //手指触摸动作结束
           touchEnd: function () {

           },
           //启动橡皮擦方法
           clearCanvas: function () {
             if (this.isClear) {
               this.isClear = false;
             } else {
               this.isClear = true;
             }
           },
           penSelect: function (e) { //更改画笔大小的方法
             console.log(e.currentTarget);
             this.setData({ pen: parseInt(e.currentTarget.dataset.param) });
             this.isClear = false;
           },
           colorSelect: function (e) { //更改画笔颜色的方法
             console.log(e);
             console.log(e.currentTarget);
             this.setData({ color: e.currentTarget.dataset.param });
             this.isClear = false;
           }
         })
         ```
##  open-data
    <view>
      <open-data type="userNickName"  lang="zh_CN" ></open-data>//昵称
    </view>
    <view>
      <open-data type="userAvatarUrl"  lang="zh_CN"></open-data>//头像
    </view>
    <view>
      <open-data type="userGender"  lang="zh_CN" ></open-data>//性别
    </view>
    <view>
      <open-data type="userCity"  lang="zh_CN" ></open-data>//城市
    </view>
    <view>
      <open-data type="userProvince"  lang="zh_CN" ></open-data>//省
    </view>
    <view>
      <open-data type="userCountry"  lang="zh_CN"></open-data>//国家
    </view>
    <view>
      <open-data type="userLanguage" lang="zh_CN" ></open-data>//语言
    </view>
##  web-view
    <web-view></web-view> //web-view类似web端的iframe,可以把页面引进小程序,而不同的是,小程序提供了页面和小程序的通信方法
## API
        1:wx.downLoadFile
        <button bindtap="downLoadFile">下载</button>
        <progress show-info percent="{{percent}}"></progress>
        <image src="{{src}}"></image>
       let that=this;
       const downloadTask= wx.downloadFile({//每一个微信的api都会返回一个监听对象,来监视api的运行情况
            url:this.filePath,
            success:(res)=>{
              console.log(res);
              this.setData({
                src:res.tempFilePath
              })
            },
            error:()=>{

            },
            complete:()=>{

            }
          })
        // downloadTask.abort();//终止下载任务
        downloadTask.onProgressUpdate(res=>{//监听下载进度
           console.log('下载进度',res.progress);//下载进度
           console.log('已经下载',res.totalBytesWritten);//已经下载总量
           console.log('下载总长度',res.totalBytesExpectedToWrite);//下载总量
           that.setData({
             percent: res.totalBytesWritten / res.totalBytesExpectedToWrite*100//设置了进度条
           })
           that.setData({
             percent: res.progress
          })
        })
        2:wx.chooseImage,wx.uploadFile
        wx.chooseImage({
          success: function(res) {
            console.log(res);
            const uploadTask = wx.uploadFile({
              url: 'https://www.baidu.com',
              filePath: res.tempFilePaths[0],
              name: 'pic1',
              success:(res)=>{
                console.log(res);
              },
              error:(err)=>{
                console.log('错了',err);
              }
            })
          },
        })
#录音和播放
       1:停止维护版本
       //开始录音
         recordVoice(){
           let  that=this;
           wx.startRecord({ //开始录音
             success(res){//录音完成
               console.log('success',res);
               that.tempVoice=res.tempFilePath
             },
             fail(res){//录音失败触发
                 console.log('falil',res);
             }
           })
           setTimeout(()=>{
               wx.stopRecord();//关闭录音
           },5000)
         },
         /**
          * 播放音频
          */
         playVoice(){
           let that=this;
           wx.playVoice({//播放录音
             filePath: that.tempVoice
           })
         }
       2:推荐版本
           const recorderManager=wx.getRecorderManager();
           const innerAudioContext=wx.createInnerAudioContext();
         /***
          * 开始录音
          */
         start(){
           const options={
             duration:10000,//录音时长
             sampleRate:16000,//采样率
             numberOfChannels:1,//录音通道数
             encodeBitRate:96000,//编码码率
             format:'mp3',//音频格式,有效aac/mp3
             frameSize:50//指定帧大小,单位kb
           }
           recorderManager.start(options);//来时录音
           recorderManager.onStart(()=>{//监听开始录音
               console.log('start');
           })
           recorderManager.onError((err)=>{//录音出错
             console.log(err);
           })
         },
         /**
          * 停止录音
          */
         stop(){
           let that=this;
           recorderManager.stop();//停止录音
           recorderManager.onStop((res)=>{//监听停止录音
             that.tempFilePath=res.tempFilePath;
             console.log('停止录音',res.tempFilePath);
           })
         },
         /**
          * 播放录音
          */
         play(){
           innerAudioContext.autoplay=true;//设置录音伯刚
           innerAudioContext.src = that.tempFilePath;
           innerAudioContext.onPlay(()=>{//播放录音
             console.log('播放');
           })
           innerAudioContext.onError((err)=>{//播放录音出错 触发事件
             console.log('err');
           })
         }
##   websocket
       senMsg(){
        let that = this;
        wx.sendSocketMessage({
          data: that.message
        })
        //监听数据是否成功
        wx.onSocketMessage((data) => {
          console.log('接收到服务器的数据', data);
          that.setData({
            respnoseMessage: data.data.replace("[<a href='http://coolaf.com/tool/chattest'>http://coolaf.com</a>]",'')
          })
        })
        wx.onSocketError((data => {
          console.log(data);
          that.setData({
            respnoseMessage:data.data
          })
        }))
      },
      /**
       * 获取发送内容
       */
      recodeMessage(e){
        this.message=e.detail.value;
      },
      /**
     * 生命周期函数--监听页面显示
     */
    onShow: function () {
      //建立连接
      wx.connectSocket({
        url: 'ws://123.207.167.163:9010/ajaxchattest' //临时在线测试地址
      })
      //判断连接是否成功
      wx.onSocketOpen(() => {
        console.log('打开连接成功');
      })
    },

    /**
     * 生命周期函数--监听页面隐藏
     */
    onHide: function () {
      //关闭连接
      wx.closeSocket({});
      //关闭连接失败
      wx.onSocketClose(() => {
        console.log('关闭了');
      });
    },
##  背景音乐
    1:第一种   BackgroundAudio
     /**
       * 播放
       */
      play(){
        console.log(url);
        wx.playBackgroundAudio({
          dataUrl: url,
          title:'此时此刻',
          coverImgUrl:'http://y.gtimg.cn/music/photo_new/T002R300x300M000003rsKF44GyaSk.jpg?max_age=2592000'
        })
        wx.onBackgroundAudioPlay(()=>{
          console.log('开始播放了');
        })
      },
      /**
       * 暂停
       */
      pause(){
        wx.pauseBackgroundAudio();
        wx,wx.onBackgroundAudioPause(()=>{
          console.log('暂停');
        })
      },
      /**
       * 停止
       */
      stop(){
        wx.stopBackgroundAudio();
        wx.onBackgroundAudioStop(()=>{
          console.log('stop');
        })
      },
      /**
       * 跳转
      */
      seek(){
        wx.seekBackgroundAudio({
          position: 20,
        })
      },

      2:第二种 backgroundAudioManager
      const backgroundAudioManager=wx.getBackgroundAudioManager();
      /**
         * 播放
         */
        play(){
          backgroundAudioManager.title='此时此刻';
          backgroundAudioManager.epname='此时此刻';
          backgroundAudioManager.singer='许巍';
          backgroundAudioManager.coverImgUrl ='http://y.gtimg.cn/music/photo_new/T002R300x300M000003rsKF44GyaSk.jpg?max_age=2592000';
          backgroundAudioManager.src ='http://ws.stream.qqmusic.qq.com/M500001VfvsJ21xFqb.mp3?guid=ffffffff82def4af4b12b3cd9337d5e7&uin=346897220&vkey=6292F51E1E384E06DCBDC9AB7C49FD713D632D313AC4858BACB8DDD29067D3C601481D36E62053BF8DFEAF74C0A5CCFADD6471160CAF3E6A&fromtag=46';
        },
        /***
         * 暂停
         */
        pause(){
          backgroundAudioManager.pause();
          backgroundAudioManager.onPlay(()=>{
            console.log('暂停');
          })
        },
        /**
         * 停止
         */
        stop(){
         backgroundAudioManager.stop();
         backgroundAudioManager.onStop(()=>{
           console.log('stop');
         })
        },
        /*
        *跳转
        */
        seek(){
          backgroundAudioManager.seek(20);
        }
##  图片
       1:选择图片
       chooseimage(){
           let  that=this;
           wx.chooseImage({//选择图片
             success: function(res) {
               console.log(res); //获取图片结果
                 that.setData({
                   upateImage: res.tempFilePaths
                   tempFilePaths: res.tempFilePaths
                 })
             }
           })
       }
       2:获取图片相关信息
        getImageInfo(){
           let that=this;
           wx.getImageInfo({
             src: that.data.tempFilePaths[0] //图片路径
             success(res){
               console.log(res);
             }
           })
         }
       3:预览图片
        previewImage(){
           let that=this;
           wx.previewImage({
             urls: [that.data.tempFilePaths[0]] //预览图片的地址,可以是多个
           })
        }
       4:下载保存图片
        downLoadService(){ //下载保存都在一起写
           let that=this;
            wx.downloadFile({//下载文件
              url:that.data.serviceImage,//下载文件路径
              success(res){
               wx.saveImageToPhotosAlbum({//保存到相册
                  filePath: res.tempFilePath,
                  success(){
                    console.log('保存成功了');
                  },
                  fail(err){
                    console.log(err);
                  }
                })
              }
            })
        }
##  loading 层
    1:内部组件loading层
         <loading hidden="{{true}}">加载中</loading>
    2:api的形式loading层
        1:wx.showToast
            wx.showToast({
             title: '加载中',
             icon:'loading',
             duration:2000, //2m后关闭
             mask:true
            })
         wx.hideToast();//关闭时间前,提前关闭层
        2:showLoading
            wx.showLoading({
              title: '加载中'
            })
            wx.hideLoading();//关闭
##  文件操作
     /**
       * 保存文件
       * 保存文件到本地,会移动临时文件
       */
      saveFile(){
        wx.chooseImage({
          success: function(res) {
            const tempfile=res.tempFilePaths[0];
            //保存
            wx.saveFile({
              tempFilePath: tempfile,
              success(res){
                const saveFilePath=res;
                console.log(saveFilePath)
                //图片存储的路径; C:\Users\Administrator\AppData\Local\微信开发者工具\User Data
                //搜索文件名
              }
            })
            //保存至相册
            wx.saveImageToPhotosAlbum({
              filePath: tempfile,
              success(res){
                  console.log(res);
              }
            })
            //保存至视频目录
            wx.saveVideoToPhotosAlbum({
              filePath: tempfile,
              success(res){
                console.log('保存到视频目录');
              }
            })
          },
        })
      },
      /***
       * 获取本地临存储文件
       */
      getFileInfo(){
        wx.chooseImage({
          success: function(res) {
            wx.getFileInfo({
              filePath: res.tempFilePaths[0],
              success(res){
                console.log(res);
                console.log(res.size);//文件大小
                console.log(res.digest);//计算算法 md5/sha1
              }
            })
          },
        })
      },
      /***
       *获取保存文件列表
       */
      getSaveFileList(){
        wx.getSavedFileList({
          success(res){
            console.log(res);
          }
        })
      },
      /**
       * 删除临时文件列表
       */
      removeSaveFile(){
        wx.getSavedFileList({
          success(res){
            //删除
            for(let i=0;i<res.fileList.length;i++){
                wx.removeSavedFile({
                  filePath: res.fileList[i].filePath,
                  success(e){
                    console.log('success',e);
                  },
                  fail(e){
                    console.log('fail',e);
                  },
                  complete(e){
                    console.log('complete',e);
                  }
                })
            }
          }
        })
      },
      /***
       * 打开文件
       */
      openDocument(){
        wx.downloadFile({
          url:'http://g.hiphotos.baidu.com/image/pic/item/c2cec3fdfc03924590b2a9b58d94a4c27d1e2500.jpg',
          success(res){
            console.log(res);
            wx.openDocument({
              filePath: res.tempFilePath,//打开文件路径
              fileType:'jpeg',
              success(res){
                console.log('文件已经打开',res);
              },
              fail(e){
                console.log(e);
              }
            })
          },
          fail(e){
            cosnole.log(e);
          }
        })
      }
# 事件
    catchtap,bindtap
    catchtap:阻止冒泡事件 (从内向外)
    bindtap:不阻止冒泡事件
    capture:tap: 捕获事件 (从外向内)
# 通过属性给方法传值
     <view class="{{classArr[index]}}" data-index="{{index}}" bindtap="changeActive">{{item.title}}</view> //data-index="{{index}}" index是要传递的值
     在bindtap函数里面通过 event.currentTarget.dataset.index来接收



